## Chapter 2: Factory Pattern 工厂模式
<div align=center>
	<img src="./image/chapter-2/0.jpg" width="">
</div>


</br>
在阅读完这一章之后，我理解的工厂模式是一种对于获取对象过程中的抽象，希望能够利用公共的接口来统一的提供实例化对象的服务。同时在工厂模式中由于将实例化对象解耦于当前对象，相对于传统的构造函数，可以完成更加复杂的初始化操作。并且我们在向系统中添加新的类的时候不需要进行大量的修改,当然，我们也可以使用反射机制来解决这个问题，我觉得也是一个不错的做法，不过或许需要注意一下软引用的问题。

</br>
ps：有一种面向接口编程的感觉

</br>

## 1. Definition
本文中主要介绍了三种模式，分别是简单工厂模式，工厂方法模式，抽象工厂模式


</br>

## 2. Design UML

</br>

缺失ing

</br>

> 抽象类：产品家族，由具体工厂生产


</br>

> 抽象工厂类：定义了一个接口，所有的具体工厂都必须实现此接口，包含一组方法用来生产产品

</br>

> 具体工厂类：具体工厂实现了不同的产品家族，只需要使用工厂而不需要实际自己序列化对象

</br>

Q&A: 工厂方法是不是隐藏在抽象工厂里？

是

</br>

## 3. Design Example

</br>

### 3.1 披萨店

</br>

披萨店可以产生不同种类的披萨，奶油披萨，芝士披萨等，同时不同地区的披萨店都有自己的特色产品如芝加哥披萨等。

</br>

### i. 错误示范
</br>
方案1：直接依赖于披萨店类来生产披萨

```Java

public  orderPizza (String type) {
    Pizza pizza;
    if(type.equals("cheese")){
        pizza=new CheesePizza();
    }else if(type.equals("greek")){
        pizza=new GreekPizza();
    }else if(type.equals("clam")){
        pizza=new ClamPizza();
    }
    pizza.prepare();
    pizza.bake();
    pizza.cute();
    return pizza;

}
```


</br>
问题分析

</br>

> 1. 单品咖啡+调料组合过多
> 2. 不符合依赖倒置原则
> 3. 最好将创建对象转移到ordderPizza()之外

</br>
方案2：简单工厂模式

</br>
问题分析

</br>

> 1. 解耦不是很彻底，还是有大量的条件判断代码
> 2. 在增加或者删除披萨种类时，代码的维护量较大。

### ii. 使用工厂模式

</br>
让子类决定改创建的对象是什么

### iii. 抽象工厂模式

</br>
是工厂方法的一个延申，因为在工厂方法中只有一个抽象方法，如果想实现多种不同的类的对象，只能去创建不同的具体工厂方法的子类来实例化，而抽象工厂的作用则是让一个工厂负责创建多个不同类型的对象。
</br>


</br>

## 4. Applying
</br>


